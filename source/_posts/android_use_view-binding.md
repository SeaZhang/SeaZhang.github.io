---
title: Android 使用 view-binding 代替 butterkinfe
date: 2020-05-26 12:12:50
tags: [Android,View-binding,视图绑定]
---



### 背景：

近期由于考虑对一批使用依赖库版本进行集中更新一次，发现 JakeWharton 大神开发维护 UI 注入库  [butterkinfe](<https://github.com/JakeWharton/butterknife>) 的 README 文件中描述该库已经不再维护，让转到 [view-binding](https://developer.android.google.cn/topic/libraries/view-binding?hl=zh-cn) 库上。



### 库功能介绍：

在模块中启用视图绑定后，系统会为该模块中每个 XML 布局文件生成一个绑定类。绑定类实例包含对相应布局中**具有 ID** 的所有视图的直接饮用。

大多数情况下，视图绑定会替代 `findViewById` 。



### 使用说明：



#### 配置

在 [Android Studio 3.6 Canary 11 及更高版本](https://developer.android.com/studio/preview?hl=zh-cn) 中可用。

视图绑定可以按模块进行启用，要在某个模块中启用，请在模块 `build.gradle` 文件中添加启用配置：

```groovy
android {
        ...
        viewBinding {
            enabled = true
        }
    }
```



如果不希望在某个布局中使用，可以在该布局文件根视图中添加 `tools:viewBindingIgnore="true"` 

```xml 
<LinearLayout
            ...
            tools:viewBindingIgnore="true" >
        ...
    </LinearLayout>
```


<!-- more -->

#### 使用

如上说，模块启用视图绑定功能后，会为该模块中包含每个 XML 布局文件各生成一个绑定类。生成的绑定类名称为对应该 XML 文件名转换为驼峰式大小写，并在末尾添加“Binding”一词。

例如，模块中一个布局名为为 `activity_spi.xml` :

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <Button
        android:id="@+id/go_spi"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="ServiceLoader Test"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        />

</androidx.constraintlayout.widget.ConstraintLayout>
```

视图绑定库会生成一个类名为 `ActivitySpiBinding`,该类有一个字段：名为 goSpi 的 TextView。

每个视图绑定类中还会包含一个 `getRoot()` 方法，用于对相应布局的根视图提供直接引用。在这个实例中会 `ActivitySpiBinding` 类中返回一个 `getRoot()` 方法返回 `ConstraintLayout` 根视图。

具体获取绑定类实例可以通过 `inflate()`方法。通常调用 `setContentView()` 将绑定视图的根视图作为参数进行传递，设置到屏幕活动视图上。



例如以上 `activity_spi.xml` 对应 Activity 的 `SPIPlayActivity` 中:

```java
 	private ActivitySpiBinding binding;

    @Override
    protected ViewBinding viewBinding() {
        binding = ActivitySpiBinding.inflate(getLayoutInflater());
        return binding;
    }
```

现在绑定类的实例就可以用于其中的视图：

```java
 binding.goSpi.setOnClickListener(this);
```



### 与 findViewById 的区别

与使用 `findViewById` 相比，视图绑定具有一些很显著的优点：

- **Null 安全**：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 `@Nullable` 标记。
- **类型安全**：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。

这些差异意味着布局和代码之间的不兼容性可能会导致编译版本在编译时（而非运行时）失败。



### 与数据绑定库的区别

视图绑定和[数据绑定库](https://developer.android.com/topic/libraries/data-binding?hl=zh-cn)均会生成可用于直接引用视图的绑定类。不过，这两者之间存在明显差异：

- 数据绑定库仅处理使用 `<layout>` 代码创建的数据绑定布局。
- 视图绑定不支持布局变量或布局表达式，因此它不能用于在 XML 中将布局与数据绑定。



### 大致机制梳理

视图绑定库不是类似 Jetpack 一个官方独立的 Lib 库的形式通过在显式引入方式进行使用。它是 Android Studio 提供的功能，在对应工程配置文件中进行一个属性配置后，build 工程后 Android Studio 会自动为启用模块中 XML 生成对应的绑定类，因此该功能为项目工程编译时自动生成相关绑定类，立等可取。

例如上面的 `activity_spi.xml` 布局文件，在工程编译完成后会自动生成如下文件：

会在工程 build 目录下对应 

在 `app/build/generated/data_binding_base_class_source_out/debug/out/org/sea/learn/databinding/` 生成一个 `ActivitySpiBinding.java` 文件。



![app-build-generated](/assets/blogImages/app-build-generated.png)



这里贴下生成的文件内容：

```java
// Generated by view binder compiler. Do not edit!
package org.sea.learn.databinding;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.constraintlayout.widget.ConstraintLayout;
import androidx.viewbinding.ViewBinding;
import java.lang.NullPointerException;
import java.lang.Override;
import java.lang.String;
import org.sea.learn.R;

public final class ActivitySpiBinding implements ViewBinding {
  @NonNull
  private final ConstraintLayout rootView;

  @NonNull
  public final Button goSpi;

  private ActivitySpiBinding(@NonNull ConstraintLayout rootView, @NonNull Button goSpi) {
    this.rootView = rootView;
    this.goSpi = goSpi;
  }

  @Override
  @NonNull
  public ConstraintLayout getRoot() {
    return rootView;
  }

  @NonNull
  public static ActivitySpiBinding inflate(@NonNull LayoutInflater inflater) {
    return inflate(inflater, null, false);
  }

  @NonNull
  public static ActivitySpiBinding inflate(@NonNull LayoutInflater inflater,
      @Nullable ViewGroup parent, boolean attachToParent) {
    View root = inflater.inflate(R.layout.activity_spi, parent, false);
    if (attachToParent) {
      parent.addView(root);
    }
    return bind(root);
  }

  @NonNull
  public static ActivitySpiBinding bind(@NonNull View rootView) {
    // The body of this method is generated in a way you would not otherwise write.
    // This is done to optimize the compiled bytecode for size and performance.
    String missingId;
    missingId: {
      Button goSpi = rootView.findViewById(R.id.go_spi);
      if (goSpi == null) {
        missingId = "goSpi";
        break missingId;
      }
      return new ActivitySpiBinding((ConstraintLayout) rootView, goSpi);
    }
    throw new NullPointerException("Missing required view with ID: ".concat(missingId));
  }
}
```

可以看出该绑定类内部在调用 `inflate` 提供根视图实例时进行页面 `inflate`初始化布局和布局元素 `findViewById`初始化赋值操作。



在  `build/intermediates` 目录下面有如下几个相关子目录：



![app-build-intermediates](/assets/blogImages/app-build-intermediates.png)



在目录  `app/build/intermediates/data_binding_base_class_log_artifact/debug/out/` 下面生成一个 `org.sea.learn-binding_classes.json` 文件。文件内容如下：

```json
{
  "mappings": {
    "activity_main": {
      "qualified_name": "org.sea.learn.databinding.ActivityMainBinding",
      "module_package": "org.sea.learn.databinding",
      "variables": {},
      "implementations": []
    },
    "activity_dagger": {
      "qualified_name": "org.sea.learn.databinding.ActivityDaggerBinding",
      "module_package": "org.sea.learn.databinding",
      "variables": {},
      "implementations": []
    },
    "activity_spi": {
      "qualified_name": "org.sea.learn.databinding.ActivitySpiBinding",
      "module_package": "org.sea.learn.databinding",
      "variables": {},
      "implementations": []
    }
  }
}
```

该文件记录模块内进行视图绑定生成的绑定类相关信息。



在目录  `app/build/intermediates/data_binding_layout_info_type_merge/debug/out/` 下面生成一个  `activity_spi-layout.xml`  文件，文件内容如下：

```xml
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<Layout directory="layout" filePath="app/src/main/res/layout/activity_spi.xml"
    isBindingData="false"
    isMerge="false" layout="activity_spi" modulePackage="org.sea.learn"
    rootNodeType="androidx.constraintlayout.widget.ConstraintLayout">
    <Targets>
        <Target tag="layout/activity_spi_0"
            view="androidx.constraintlayout.widget.ConstraintLayout">
            <Expressions />
            <location endLine="17" endOffset="51" startLine="1" startOffset="0" />
        </Target>
        <Target id="@+id/go_spi" view="Button">
            <Expressions />
            <location endLine="15" endOffset="9" startLine="6" startOffset="4" />
        </Target>
    </Targets>
</Layout>
```

该文件记录对应布局文件下视图组件里布局名称，归属包名路径，根视图类型等相关信息。



另外同样在目录  `app/build/intermediates/` 目录下面的子目录  `data_binding_base_class_logs_dependency_artifacts`，`data_binding_dependency_artifacts` 两个目录也相关编译生成目录，目前暂时未发现里面有生成对应文件存在。



大致做个小结：视图绑定 `view-binding` 是 Android Studio 提供的视图绑定功能，模块添加启用配置后，编译工程后，相关 xml 布局均会生成视图绑定类，里面包含了视图初始化，视图内各组件子视图初始化，供具体布局视图中进行使用。具体深层次工程编译生成相关目录文件及对应映射关系及最终生产视图绑定类轮询生成的过程有待进一步发掘。



### 参考资料链接：

 [view-binding](https://developer.android.google.cn/topic/libraries/view-binding?hl=zh-cn) 

